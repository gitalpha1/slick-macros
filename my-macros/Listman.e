
/*****************************************************************************
*  COPYRIGHT : This code is written by, and copyright to Graeme F Prentice.
*              You may not distribute this code in whole or in part or use it
*              in a commercial product without permission from the author in
*              writing.   
*****************************************************************************/


/******************************************************************************
*  $Revision: 1.1 $                                                            
******************************************************************************/

#include "slick.sh"
#include "Listman.sh"


#pragma option(strictsemicolons,on)
#pragma option(strict,on)
#pragma option(autodecl,off)
#pragma option(strictparens,on)


#define USE_TREE yes

#define LISTMAN_VERSION '1.0'

#define LIST_DATA_FOLDER_PATH _config_path() :+ FILESEP :+ 'Listman' :+ FILESEP :+ 'ListDataFiles'

//#define FIRST_LIST_DATA_FILENAME LIST_DATA_FOLDER_PATH :+ FILESEP :+ 'FirstList.dat'
//#define GLOBAL_LIST_DATA_FILENAME LIST_DATA_FOLDER_PATH :+ FILESEP :+ 'GlobalLists.dat'

#define FIRST_LIST_DATA_FILENAME LIST_DATA_FOLDER_PATH :+ FILESEP :+ 'FirstList.xml'
#define GLOBAL_LIST_DATA_FILENAME LIST_DATA_FOLDER_PATH :+ FILESEP :+ 'GlobalLists.xml'


#define FAVORITES_LIST_NAME '<Favorites>'
#define EXTERNAL_LIST_NAME '<External>'

#if __UNIX__
#define VUSRDEFS_FILENAME 'vunxdefs.e'
#else
#define VUSRDEFS_FILENAME 'vusrdefs.e'
#endif

defeventtab ListmanForm;



static _str listman_datafile_name;

int gfp_def_GFileman_key_shortcuts_active = 1;
int switch_list_on_project_switch = 1;

struct list_item {
   _str name;
   _str key;
   int next;
   int prev;
   int flags;
};

#define FFMASK_OPEN_EXTERNALLY 1


struct a_list {
   _str                 list_name;
   list_item            list_items[];
   int                  most_recent;
   int                  list_flags;
};

// list_flags are
#define LFMASK_LIST_IS_GLOBAL 1


// all the lists
static a_list    the_lists[];

static boolean list_data_has_been_modified;

struct active_shortcut_hash_item {
   _str name;
   int flags;
};

// this hash table is indexed by key name and holds the (file)name for that key
static active_shortcut_hash_item active_shortcut_list :[];
static _str reverse_active_shortcut_list :[];
static active_shortcut_hash_item  last_looked_up_active_shortcut_item;
static int global_item_flags;

static int selected_list;
static int active_list;
static _str selected_list_name;
static _str active_list_name;

// file_list1, file_list2 and key_list1 are generated by the dialog and used to
// populate the listbox of filenames.  file_list1 holds filenames that have
// an assigned shortcut - the shortcut is in the corresponding element of key_list1
static _str file_list1[];
static _str key_list1[];
static int flags_list1[];

#ifdef USE_TREE
// these are needed so the index into the tree can be retrieved given the
// index into flags_list1/2  - items shown in the tree "listbox" do not have
// sequential indexes.
static int tree_item_index_list1[];
static int tree_item_index_list2[];

static int filelist_sort_mode;
static int filelist_sort_order;


#endif

static _str file_list2[];
static int flags_list2[];

static int filename_listbox_data_type;
#define LISTBOX_SHOWS_OPEN_BUFFERS 0
#define LISTBOX_SHOWS_SELECTED_LIST 1
#define LISTBOX_SHOWS_PROJECT 2
#define LISTBOX_SHOWS_FAVORITES 3
#define LISTBOX_SHOWS_EXTERNAL 4
#define LISTBOX_SHOWS_SUPERLIST 5


_control FilenameEditbox;
_control ctllabel1;
_control InfoLabel1;
_control FilenameListbox;
_control ActiveProjectNameEditbox;
_control RemoveFilesButton;
_control UnbindButton;
_control ctllabel4;
_control ListNamesListBox;
_control FileListTree;

_control OpenBuffersRadioButton;
_control SelectedListRadioButton;
_control FavoritesRadioButton;
_control ActiveProjectRadioButton;
_control ExternalRadioButton;

_control SelectedListNameEditbox;
_control ActiveListNameEditBox;

_control AutoNewListCheckButton;
_control SwitchOnNewProjectCheckBtn;
_control AutoUpdateListCheckBtn;

_control ListNamesListBoxComboLabel;
_control ListNamesListBoxCombo;
_control FileListBoxComboLabel;
_control FileListBoxSelectorCombo;

_control NewListButton;
_control AddFilesButton;
_control ListnamesMoreButton;
_control OpenAllFilesButton;
_control SetListActiveButton;

_control FilelistMoreButton;
_control SwitchMasterButton;
_control FileListBoxComboLabel;
_control SaveListsButton;

static int AutoNewListCheckButton_value = 1;

static _str selective_filename_match_string;
static int last_radio_button_selected = LISTBOX_SHOWS_OPEN_BUFFERS;


static int pic_index_col1_active_file;
static int pic_index_col1_blank;
static int pic_index_col1_selected_file;
static int pic_index_col1_selected_active_file;

static int listnames_listbox_index[];
static int filename_listbox_total_items;
static boolean sel_combo_has_focus;
static int menu_save_active_form_id;






/*=============================================================================

            Functions below are all those which modify list data.  

     They all set the list_data_has_been_modified flag true when they do.

=============================================================================*/


static int create_new_list(_str name)
{
   int k = the_lists._length();
   the_lists[k].list_name = name;
   the_lists[k].list_flags = 0;
   the_lists[k].most_recent = 0;
   the_lists[k].list_items._makeempty();
   list_data_has_been_modified = true;
   return k;
}


static void add_item_to_list(int list_index, _str key, _str fname, int flags = 0)
{
   boolean done = false;
   int free = -1;
   if (list_index < 0 || list_index >= the_lists._length()) 
      return;

   int k;
   for (k = 0; k < the_lists[list_index].list_items._length(); ++k) {

      if (the_lists[list_index].list_items[k].key :== key) {
         if (the_lists[list_index].list_items[k].name :== fname) {
            return;
         }
         // this key no longer belongs with this file so erase it
         the_lists[list_index].list_items[k].key = '';
         list_data_has_been_modified = true;
         if (done) 
            return;
      } else if (the_lists[list_index].list_items[k].name :== fname) {
         the_lists[list_index].list_items[k].key = key;
         list_data_has_been_modified = true;
         // the file / key pair are now in the list but we need to keep 
         // stepping through the list in case the key is still present 
         done = true;
      } else if (the_lists[list_index].list_items[k].name == '') {
         free = k;
      }
   }
   if (free == -1) {
      free = k;
   }
   if (!done) {
      the_lists[list_index].list_items[free].key = key;
      the_lists[list_index].list_items[free].name = fname;
      the_lists[list_index].list_items[free].flags = flags;
      list_data_has_been_modified = true;
   }
}

static void remove_item_from_list(int list_index, _str name)
{
   if (list_index < 0 || list_index >= the_lists._length()) 
      return;

   int k;
   for (k = 0; k < the_lists[list_index].list_items._length(); ++k) {
      if (the_lists[list_index].list_items[k].name == name) {
         the_lists[list_index].list_items[k].key = '';
         the_lists[list_index].list_items[k].name = '';
         list_data_has_been_modified = true;
         return;
      }
   }
}

static void set_list_item_options(int list_index, _str name, int flags)
{
   if (list_index < 0 || list_index >= the_lists._length()) 
      return;

   int k;
   for (k = 0; k < the_lists[list_index].list_items._length(); ++k) {
      if (the_lists[list_index].list_items[k].name == name) {
         the_lists[list_index].list_items[k].flags = flags;
         list_data_has_been_modified = true;
         return;
      }
   }
}

static void remove_key_from_list(int list_index, _str name)
{
   if (list_index < 0 || list_index >= the_lists._length()) 
      return;

   int k;
   for (k = 0; k < the_lists[list_index].list_items._length(); ++k) {
      if (the_lists[list_index].list_items[k].name == name) {
         the_lists[list_index].list_items[k].key = '';
         list_data_has_been_modified = true;
         return;
      }
   }
}

_command void Listman_toggle_list_global_status() name_info(',')
{
   if (the_lists[selected_list].list_flags & LFMASK_LIST_IS_GLOBAL) {
      the_lists[selected_list].list_flags &= ~LFMASK_LIST_IS_GLOBAL;
   } else {
      the_lists[selected_list].list_flags |= LFMASK_LIST_IS_GLOBAL;
   }
   list_data_has_been_modified = true;
   populate_filename_listbox(true, false, true, true, true, menu_save_active_form_id);
}

_command void Listman_delete_selected_list() name_info(',')
{
   int result =_message_box("Delete list?" \n :+ selected_list_name, 'Listman', MB_YESNO|MB_ICONQUESTION);
   if (result == IDYES) {
      the_lists[selected_list].list_name = '';
      the_lists[selected_list].list_items._makeempty();
      list_data_has_been_modified = true;
      check_if_selected_list_is_valid(true);  // it isn't, so it will be reassigned
      populate_filename_listbox(true, false, true, true, true, menu_save_active_form_id);
   }
}

_command void Listman_rename_selected_list()
{
   int form_id = p_active_form;
   int result = textBoxDialog("Rename list", // Form caption
                              TB_RETRIEVE,      // Flags
                              0,                // Use default textbox width
                              "",               // Help item
                              "",
                              "",  // Retrieve Name
                              "Enter new name:" selected_list_name);
   if ((result != COMMAND_CANCELLED_RC) && _param1 != '') {
      if (find_listname_index(_param1) >= 0) {
         _message_box('List is already present -  ' :+ _param1);
         return;
      }
      the_lists[selected_list].list_name = _param1;
      list_data_has_been_modified = true;
      selected_list_name = _param1;
      populate_filename_listbox(true, false, true, true, true, form_id);
   }


}


/* =============================================================================

             Functions above are all those which modify list data.  

      They all set the list_data_has_been_modified flag true when they do.

==============================================================================*/



#define XML_LIST_INDENT_STRING "\x20\x20\x20"
#define XML_LIST_INDENT_STRING2 XML_LIST_INDENT_STRING :+ XML_LIST_INDENT_STRING
#define XML_LIST_INDENT_STRING3 XML_LIST_INDENT_STRING2 :+ XML_LIST_INDENT_STRING
#define XML_LIST_INDENT_STRING4 XML_LIST_INDENT_STRING3 :+ XML_LIST_INDENT_STRING



static _str encode_xml_special_chars(_str str1)
{
   // convert <>& to sequence
   str1 = stranslate(str1, "&amp;", "&");
   str1 = stranslate(str1, "&gt;", ">");
   str1 = stranslate(str1, "&lt;", "<");
   str1 = stranslate(str1, "&quot;", "\"");
   str1 = stranslate(str1, "&apos;", "'");
   return str1;
}



static void insert_xml_lists(int format = 1, boolean global_lists = false)
{
   int k;
   for (k = 0; k < the_lists._length(); ++k) {
      if (the_lists[k].list_name == '') {
         continue;
      }
      boolean gf = false;
      if (the_lists[k].list_name == FAVORITES_LIST_NAME || 
          the_lists[k].list_name == EXTERNAL_LIST_NAME ||
          the_lists[k].list_flags & LFMASK_LIST_IS_GLOBAL) {
         gf = true;
      }
      // are we saving global or non-global lists?
      if (global_lists && !gf || !global_lists && gf) 
         continue;

      insert_line(XML_LIST_INDENT_STRING2 :+ '<List Name="' :+ encode_xml_special_chars(the_lists[k].list_name) '">');
      int j = 0;
      while (j < the_lists[k].list_items._length()) {
         _str keyn = the_lists[k].list_items[j].key;
         if (keyn == '') {
            keyn = '--';
         }
         _str options = convert_flags_to_string_for_file(the_lists[k].list_items[j].flags);
         if (the_lists[k].list_items[j].name != '')
         {
            if (format == 2) {
               insert_line(XML_LIST_INDENT_STRING3 :+ '<Item Key="' :+ encode_xml_special_chars(keyn) :+ 
                           '" Options="' :+ encode_xml_special_chars(options) :+ '">' );
               insert_line(XML_LIST_INDENT_STRING4 :+ '<Target>' :+ 
                           encode_xml_special_chars(the_lists[k].list_items[j].name) );
               insert_line(XML_LIST_INDENT_STRING4 :+ '</Target>' ); 
               insert_line(XML_LIST_INDENT_STRING3 :+ '</Item>' );
            }
            else 
            {
               insert_line(XML_LIST_INDENT_STRING3 :+ '<Item  Key="' :+ encode_xml_special_chars(keyn) :+ 
                           '"  Options="' :+ encode_xml_special_chars(options) :+
                           '"  Target="'  :+ encode_xml_special_chars(the_lists[k].list_items[j].name) :+ '" />');
            }
         }
         ++j;
      }
      insert_line(XML_LIST_INDENT_STRING2 :+ '</List>');
   }

}


void save_xml_list_data_to_file(_str filename, boolean global_lists = false)
{
   int section_view, current_view;
   current_view = _create_temp_view(section_view);
   if (current_view == '') {
       return;
   }
   activate_view(section_view);
   top();
   // insert_line('<!DOCTYPE ListManData SYSTEM "http://www.slickedit.com/dtd/vse/Graeme/ListManData.dtd">');
   insert_line('<ListManData Date="' :+ _date('L') :+ '" Format="1" ListmanVersion="' :+ LISTMAN_VERSION :+ '" >');
   insert_line(XML_LIST_INDENT_STRING :+ '<ListSet Name="ListSet1">');    // name unused for now
   insert_xml_lists(1,global_lists);
   insert_line(XML_LIST_INDENT_STRING :+ '</ListSet>');
   insert_line('</ListManData>');

   _save_file('-Z -ZR -E -S -L +DD -O ' :+ filename);
   _delete_temp_view(section_view);
   activate_view(current_view);
}



#if 0
// this function generates .ini type data
static void GFM_save_shortcut_lists2(_str list_data_filename, boolean global_lists = false)
{
   int section_view, current_view;
   current_view = _create_temp_view(section_view);
   if (current_view == '') {
       return;
   }
   activate_view(section_view);
   top();
   // need first line blank for easier load
   insert_line(' ');

   int k;
   for (k = 0; k < the_lists._length(); ++k) {
      if (the_lists[k].list_name == '') {
         continue;
      }
      boolean gf = false;
      if (the_lists[k].list_name == FAVORITES_LIST_NAME || 
          the_lists[k].list_name == EXTERNAL_LIST_NAME ||
          the_lists[k].list_flags & LFMASK_LIST_IS_GLOBAL) {
         gf = true;
      }
      if (global_lists && !gf || !global_lists && gf) 
         continue;

      insert_line('[' the_lists[k].list_name ']');
      int j = 0;
      while (j < the_lists[k].list_items._length()) {
         _str keyn = the_lists[k].list_items[j].key;
         if (keyn == '') {
            keyn = '-- ';
         }
         _str options = convert_flags_to_string_for_file(the_lists[k].list_items[j].flags);
         if (options == '') {
            options = '#';    // dummy value - need non blank
         }
         if (the_lists[k].list_items[j].name != '')
            insert_line(keyn :+ '  ' :+ options :+ '  ':+ the_lists[k].list_items[j].name);

         ++j;
      }
      insert_line('  ');
   }

   _save_file(list_data_filename);
   _delete_temp_view(section_view);
   activate_view(current_view);
}
// GFM_save_shortcut_lists2 is no longer used
#endif


static void GFM_save_shortcut_lists(_str list_data_filename, boolean force_save = false)
{
   //GFM_save_shortcut_lists2(list_data_filename, false);
   //GFM_save_shortcut_lists2(GLOBAL_LIST_DATA_FILENAME, true);

   if (!force_save && !list_data_has_been_modified) {
      return;
   }
   save_xml_list_data_to_file(list_data_filename, false);
   save_xml_list_data_to_file(GLOBAL_LIST_DATA_FILENAME, true);
   list_data_has_been_modified = false;
}



#if 0
// this function loaded .ini type data
static void load_shortcut_list_data2(_str list_data_filename, boolean global)
{
   _str line,listname,rkey,rname, roptions;
   int list_index = the_lists._length();

   if (get(list_data_filename)) {
      message('load shortcut list data file failed - FILE: ' :+ list_data_filename);
      return;
   }
   top();
   for (;;++list_index) {
      while (true) {
         if (down())
            return;
         get_line(line);
         if (substr(line,1,1) == '[') {
            listname = substr(line, 2, length(line)-2);
            break;
         }
      }
      if (listname == '') {
         continue;
      }
      // start new list and read its key/ name pairs
      the_lists[list_index].list_name = listname;
      the_lists[list_index].list_flags = (global ? LFMASK_LIST_IS_GLOBAL : 0);
      the_lists[list_index].most_recent = 0;
      the_lists[list_index].list_items._makeempty();
      int k = 0;
      while (true) {
         if (down())
            return;
         get_line(line);
         if (substr(line,1,1) == ' ')
            break;

         parse line with rkey roptions rname;
         // todo - do we want quotes here ?
         //rname = parse_file(rname,true);
         if (rkey == '--') {
            rkey = '';
         }
         the_lists[list_index].list_items[k].key = rkey;
         the_lists[list_index].list_items[k].name = rname;
         the_lists[list_index].list_items[k].flags = convert_string_to_flags_for_file(roptions);
         if (++k > 20000) {
            message('Shortcut list too long');
            return; // too many ??
         }
      }
   }
}
// load_shortcut_list_data2 not used

void GFM_load_shortcut_list_data(_str list_data_filename)
{
   int section_view, current_view;
   the_lists._makeempty();

   listman_datafile_name = list_data_filename;

   if (list_data_filename != '' && file_exists(list_data_filename)) {
      current_view = _create_temp_view(section_view, false);
      if (current_view == 0) return;
      activate_view(section_view);
      load_shortcut_list_data2(list_data_filename, false);
      _delete_temp_view(section_view);
      activate_view(current_view);
   }

   current_view = _create_temp_view(section_view);
   if (current_view == 0) return;
   activate_view(section_view);
   load_shortcut_list_data2(GLOBAL_LIST_DATA_FILENAME, true);
   _delete_temp_view(section_view);
   activate_view(current_view);
}
// GFM_load_shortcut_list_data not used
#endif



static int load_xml_shortcut_list_data2(_str list_data_filename, boolean global)
{
   _str line,listname,rkey,rname, roptions;
   int list_index = the_lists._length();

   if (!file_exists(list_data_filename)) {
      message('ListMan error - data file not found ' :+ list_data_filename);
      return 0;
   }
   int xst;
   int xhandle = _xmlcfg_open(list_data_filename, xst);

   if (xhandle < 0) {
      message('ListMan error - xml load error ' :+ xhandle :+ ' File: ' :+ list_data_filename);
      return xhandle;
   }
   int ListSet_node = _xmlcfg_find_simple(xhandle, "/ListManData/ListSet");
   if (ListSet_node < 0) {
      message( 'ListMan error - xml tag not found ListManData/ListSet - File:' :+ list_data_filename );
      return -1;
   }

   int listset_child_node = _xmlcfg_get_first_child(xhandle, ListSet_node, VSXMLCFG_NODE_ELEMENT_START | VSXMLCFG_NODE_ELEMENT_START_END );

   // iterate through the lists, if any
   for ( ; ; listset_child_node = _xmlcfg_get_next_sibling(xhandle, listset_child_node)) {
      if (listset_child_node < 0) 
         break;
      
      if (_xmlcfg_get_name(xhandle, listset_child_node) == 'List') {
         _str list_name = _xmlcfg_get_attribute(xhandle, listset_child_node, 'Name' );
         if (list_name == '') {
            continue;
         }
         //say('list ' :+ list_name);
         the_lists[list_index].list_name = list_name;
         the_lists[list_index].list_flags = (global ? LFMASK_LIST_IS_GLOBAL : 0);
         the_lists[list_index].most_recent = 0;
         the_lists[list_index].list_items._makeempty();

         int list_child_node = _xmlcfg_get_first_child(xhandle, listset_child_node, VSXMLCFG_NODE_ELEMENT_START | VSXMLCFG_NODE_ELEMENT_START_END );
         if (list_child_node < 0) {
            ++list_index;  // keep empty list
            continue;
         }
         // iterate through list items
         int item_index = 0;
         while (true) {
            if (_xmlcfg_get_name(xhandle, list_child_node) == 'Item') {
               _str target = _xmlcfg_get_attribute(xhandle, list_child_node, 'Target' );
               _str key = _xmlcfg_get_attribute(xhandle, list_child_node, 'Key' );
               _str options = _xmlcfg_get_attribute(xhandle, list_child_node, 'Options' );
               the_lists[list_index].list_items[item_index].key = (key == '--' ? '' : key);
               the_lists[list_index].list_items[item_index].name = target;
               the_lists[list_index].list_items[item_index].flags = convert_string_to_flags_for_file(options);
               ++item_index;
               //say('Item ' :+ key :+ ' ' :+ options :+ ' ' :+ target);
            }
            list_child_node = _xmlcfg_get_next_sibling(xhandle, list_child_node);
            if (list_child_node < 0) {
               break;
            }
         }
         ++list_index;
      }
   }
   return 1;
}



void GFM_load_shortcut_list_data(_str list_data_filename)
{
   the_lists._makeempty();
   listman_datafile_name = list_data_filename;

   if (list_data_filename != '' && file_exists(list_data_filename)) {
      load_xml_shortcut_list_data2(list_data_filename, false);
   }
   if (file_exists(GLOBAL_LIST_DATA_FILENAME)) {
      load_xml_shortcut_list_data2(GLOBAL_LIST_DATA_FILENAME, true);
   }
}


static boolean file_extension_might_be_external(_str ext)
{
   ext = lowcase(ext);
   switch (ext) {
      case 'exe' : return true;
      case 'doc' : return true;
      case 'pdf' : return true;
      case 'htm' : return true;
      case 'html' : return true;
      case 'bat' : return true; 
      case 'zip' : return true;
      case 'chm' : return true;
      case 'hlp' : return true;
      case 'sln' : return true;
      case 'xls' : return true;
      default:return false;
   }
}


static void do_relink_list(a_list & rlist)
{
   int k = rlist.list_items._length();

   rlist.most_recent = 0;

   int j;
   for (j = 0; j < k; ++j) {
      rlist.list_items[j].next = j + 1;
      rlist.list_items[j].prev = j - 1;
   }
   rlist.list_items[k-1].next = -1;
}


static void relink_list(int list_index)
{
   if (list_index < 0 || list_index >= the_lists._length()) 
      return;
   do_relink_list(the_lists[list_index]);
}


static void do_make_list_item_most_recent(a_list & rlist, int item_index)
{
   if (rlist.most_recent == item_index) 
      return;

   int prev = rlist.list_items[item_index].prev;
   int next = rlist.list_items[item_index].next;
   if ( prev < 0 || 
        prev >= rlist.list_items._length() || 
        next >= rlist.list_items._length()) {
      // can't have a prev index < 0 unless it's the most recent so the list is corrupt
      do_relink_list(rlist);
      return;
   }

   // set the previous item to link to the next item
   rlist.list_items[prev].next = next;
   // make item_index the first item
   rlist.list_items[item_index].next = rlist.most_recent;
   rlist.list_items[item_index].prev = -1;
   rlist.most_recent = item_index;
}


static void make_list_item_most_recent(int list_index, int item_index)
{
   if (list_index < 0 || list_index >= the_lists._length()) 
      return;
   do_make_list_item_most_recent(the_lists[list_index], item_index);
}








static int copy_selected_list()
{
   if (selected_list < 0 || selected_list >= the_lists._length()) 
   {
      _message_box('No list selected');
      return -1;
   }
   if (the_lists[selected_list].list_items._length() <= 0) {
      _message_box('List is empty  - ' :+ the_lists[selected_list].list_name);
      return -1;
   }
   _str lname = 'Copy of ' :+ the_lists[selected_list].list_name;

   if (find_listname_index(lname) >= 0) {
      _message_box('List is already present -  ' :+ lname );
      return -1;
   }
   int nlist = create_new_list(lname);
   the_lists[nlist].list_flags = LFMASK_LIST_IS_GLOBAL;
   the_lists[nlist].list_items = the_lists[selected_list].list_items;

   selected_list = nlist;
   selected_list_name = lname;

   set_radio_button(LISTBOX_SHOWS_SELECTED_LIST);
   return 0;
}


static int convert_string_to_flags_for_file(_str options)
{
   int k = length(options);
   int flags = 0;
   for (;k > 0; --k) {
      switch (substr(options,k,1)) {
         case 'E' : flags |= FFMASK_OPEN_EXTERNALLY; break;
      }
   }
   return flags;
}


// returns an empty string if no options enabled
static _str convert_flags_to_string_for_file(int flags)
{
   _str res = '';
   if (flags & FFMASK_OPEN_EXTERNALLY) {
      res = 'E';
   }
   return res;
}





static int get_list_item_flags(_str fname, int list_index)
{
   if (list_index < 0 || list_index >= the_lists._length()) 
      return 0;

   int k;
   for (k = 0; k < the_lists[list_index].list_items._length(); ++k) {
      if (the_lists[list_index].list_items[k].name :== fname) {
         return the_lists[list_index].list_items[k].flags;
      }
   }
   return 0;
}




// if key is in the hashtable then return its value, else return null
static _str lookup_active_shortcut_key_list(_str key)
{
   if (active_shortcut_list._indexin(key)) {
      last_looked_up_active_shortcut_item = active_shortcut_list:[key];
      return last_looked_up_active_shortcut_item.name;
   }
   return '';
}


// if bufname is in the reverse hashtable then return its value, else return null
_str lookup_reverse_active_shortcut_list(_str bufname)
{
   if (reverse_active_shortcut_list._indexin(bufname)) {
      return reverse_active_shortcut_list:[bufname];
   }
   return '';
}


static void add_list_to_active_shortcuts(int list_index)
{
   int k;
   if (list_index < 0 || list_index >= the_lists._length()) 
      return;

   for (k = 0; k < the_lists[list_index].list_items._length(); ++k) {
      if (the_lists[list_index].list_items[k].key != '') {

         active_shortcut_hash_item temp;
         temp.name = the_lists[list_index].list_items[k].name;
         temp.flags = the_lists[list_index].list_items[k].flags;

         active_shortcut_list:[the_lists[list_index].list_items[k].key] = temp;
         // reverse_active_shortcut_list is used to find what the shortcut key
         // (if any) is for a particular buffer
         reverse_active_shortcut_list:[the_lists[list_index].list_items[k].name] =
            the_lists[list_index].list_items[k].key;
      }
   }
}


// generate the hashtable for the list of active shortcuts
static void generate_active_shortcut_list_lookup_data(int list_index)
{
   active_shortcut_list._makeempty();
   reverse_active_shortcut_list._makeempty();

   if (list_index >= 0 && list_index < the_lists._length()) {
      add_list_to_active_shortcuts(list_index);
   }
   int k = find_listname_index(FAVORITES_LIST_NAME);
   if (k >= 0) {
      add_list_to_active_shortcuts(k);
   }
   k = find_listname_index(EXTERNAL_LIST_NAME);
   if (k >= 0) {
      add_list_to_active_shortcuts(k);
   }
}


// return index of the list if list_name is an existing list, otherwise -1
static int find_listname_index(_str list_name)
{
   int k;
   for (k = 0; k < the_lists._length(); ++k) {
      if (the_lists[k].list_name == list_name) {
         return k;
      }
   }
   return -1;
}


static int set_first_list_as_selected()
{
   int k;
   for (k = 0; k < the_lists._length(); ++k) {
      if (the_lists[k].list_name != '') {
         selected_list = k;
         selected_list_name = the_lists[k].list_name;
         return k;
      }
   }
   selected_list = -1;
   selected_list_name = '';
   return -1;
}


static void make_list_shortcuts_active(int list_index)
{
   if (list_index < the_lists._length() && list_index >= 0) {
      active_list_name = the_lists[list_index].list_name;
      active_list = list_index;
      generate_active_shortcut_list_lookup_data(list_index);
   } else {
      active_list_name = '';
      active_list = -1;
      generate_active_shortcut_list_lookup_data(-1);
   }
}


void _prjopen_GFM_load_key_shortcuts()
{
   if (switch_list_on_project_switch) {
      active_shortcut_list._makeempty();
      int k = find_listname_index(_project_name);
      if (k >= 0) {
         make_list_shortcuts_active(k);
      }
      else if (AutoNewListCheckButton_value != 0) {
         make_list_shortcuts_active(create_new_list(_project_name));
      }
   }
}


_command void GFM_check_shortcut_keys() name_info(',')
{
   // todo - deal with external files etc
   _str fname = lookup_active_shortcut_key_list(event2name(last_event()));
   if (fname != '') {
      if (last_looked_up_active_shortcut_item.flags & FFMASK_OPEN_EXTERNALLY) {
         open_external_item(fname);
      } else {
         edit(maybe_quote_filename(fname));
      }
   }
}


static _str get_vsroot_dir()
{
   _str root_dir   = get_env("VSROOT");
   _maybe_append_filesep(root_dir);
   return root_dir;
}


static void check_and_create_default_lists()
{
   if (find_listname_index(FAVORITES_LIST_NAME) < 0) {
      int k = create_new_list(FAVORITES_LIST_NAME);
      add_item_to_list(k,'C-F12',LIST_DATA_FOLDER_PATH, FFMASK_OPEN_EXTERNALLY);
      add_item_to_list(k,'S-F12',_config_path() :+ VUSRDEFS_FILENAME);
      add_item_to_list(k,'C-S-F12', strip_filename(GetErrorFilename(),'N'), FFMASK_OPEN_EXTERNALLY);
      add_item_to_list(k,'C-S-F12', strip_filename(GetErrorFilename(),'N') :+ 'vsstack');
   }

   if (find_listname_index(EXTERNAL_LIST_NAME) < 0) {
      int k = create_new_list(EXTERNAL_LIST_NAME);
      add_item_to_list(k,'C-F11',get_vsroot_dir() :+ 'docs' :+ FILESEP, FFMASK_OPEN_EXTERNALLY);
      add_item_to_list(k,'S-F11',_config_path(), FFMASK_OPEN_EXTERNALLY );
      add_item_to_list(k,'A-F11','http://www.google.com', FFMASK_OPEN_EXTERNALLY );
   }

   if (find_listname_index('<SuperList>') < 0) {
      int k = create_new_list('<SuperList>');
      add_item_to_list(k,'',LIST_DATA_FOLDER_PATH :+ FILESEP :+ 'Archive1.dat');
   }
}


ListmanForm.on_load()
{
   ctllabel1._set_focus();
}

ListmanForm.'ESC'()
{
   if (sel_combo_has_focus) {
      sel_combo_has_focus = false;
      // FileListBoxSelectorCombo.p_cb_text_box.p_text = '';  doesn't work properly!
      FileListBoxSelectorCombo.p_cb_text_box.begin_line();
      FileListBoxSelectorCombo.p_cb_text_box.delete_end_line();
      populate_filename_listbox(true, false);
   } else {
      p_active_form._delete_window();
   }
}


// get_list_item_key returns the key for the given name and also returns
// global_item_flags set up to the item flags (coz I'm too lazy to return
// a struct) - if the name isn't found, global_item_flags are set to zero
static _str get_list_item_key(_str fname, int list_index)
{
   int k;
   global_item_flags = 0;
   if (list_index < 0 || list_index >= the_lists._length()) {
      return '';
   }
   for (k = 0; k < the_lists[list_index].list_items._length(); ++k) {
      if (the_lists[list_index].list_items[k].name :== fname) {
         global_item_flags = the_lists[list_index].list_items[k].flags;
         return the_lists[list_index].list_items[k].key;
      }
   }
   return '';
}


static _str get_list_entry_text(int k)
{
   if (the_lists[k].list_name == '') {
      return '';
   }
   if (the_lists[k].list_flags & LFMASK_LIST_IS_GLOBAL) {
      return ' G   ' :+ the_lists[k].list_name;
   }
   return '      ' :+ the_lists[k].list_name;
}

static void populate_list_names_listbox(int form_id)
{
   _str stext, flgs;
   _str sort_data[];
   typeless x;
   boolean alpha_sort = true;
   int selx = -1;
   // disabling the listbox avoids the annoying dotted line that can appear
   // if the listbox receives the focus
   form_id.ListNamesListBox.p_enabled = false;
   form_id.ListNamesListBox._lbclear();

   listnames_listbox_index._makeempty();

   int k;

   if (alpha_sort) {
      sort_data._makeempty();
      for (k = 0; k < the_lists._length(); ++k) {
         stext = the_lists[k].list_name;
         if (stext != '') {
            sort_data[sort_data._length()] = stext :+ "\1" :+ k;
         }
      }
      //sort_data._sort('F'_fpos_case);
      sort_data._sort();
      for (k = 0; k < sort_data._length(); ++k) {
         parse sort_data[k] with stext "\1" x;
         listnames_listbox_index[k] = x;
         if (the_lists[x].list_flags & LFMASK_LIST_IS_GLOBAL) {
            flgs = "G\t";
         }
         else {
            flgs = "\t";
         }
         if (x == selected_list) {
            selx = k;
            if (x == active_list){
               form_id.ListNamesListBox._lbadd_item(flgs :+ stext, 20, pic_index_col1_selected_active_file);
            } else {
               form_id.ListNamesListBox._lbadd_item(flgs :+ stext, 20, pic_index_col1_selected_file);
            }
         }
         else if (x == active_list){
            form_id.ListNamesListBox._lbadd_item(flgs :+ stext, 20, pic_index_col1_active_file);
         } else {
            form_id.ListNamesListBox._lbadd_item(flgs :+ stext, 20, pic_index_col1_blank);
         }
      }
   }

   if (selx >= 0) {
      form_id.ListNamesListBox.p_line = selx + 1;
   } else {
      form_id.ListNamesListBox._lbtop();
   }
   form_id.ListNamesListBox.p_enabled = true;
}


ListNamesListBox.on_create()
{
      _SetListColInfo(0,500,LBCOLSTYLE_BUTTON,0); 
      _SetListColCaption(0,"Flags");
      _SetListColInfo(1,1000,LBCOLSTYLE_BUTTON,0);
      _SetListColCaption(1,"  List name");
}


static void populate_editboxes(int form_id)
{
   // if showing open buffers or project, then key binding goes
   // to the active list, otherwise to the selected list.
   // SelectedListNameEditBox shows the name of the list the key binding will go to

   form_id.ActiveProjectNameEditbox.p_text = _project_name;
   form_id.ActiveListNameEditBox.p_text = active_list_name;

   switch (filename_listbox_data_type) {
      case LISTBOX_SHOWS_OPEN_BUFFERS :
         form_id.SelectedListNameEditbox.p_text = '<Open Buffers>';
         break;
         /*
         if (active_list_name == '') 
            form_id.SelectedListNameEditbox.p_text = selected_list_name;
         else
            form_id.SelectedListNameEditbox.p_text = active_list_name;
         break;
         */
      case LISTBOX_SHOWS_SELECTED_LIST :
      default:
         form_id.SelectedListNameEditbox.p_text = selected_list_name;
         break;
   }
}


#ifdef USE_TREE


static void select_tree_item(int idx, int form_id = p_active_form)
{
   int state,bm1,bm2,flags;

   // Deselect all the items in the tree
   form_id.FileListTree._TreeSetAllFlags(0,TREENODE_SELECTED);

   form_id.FileListTree._TreeGetInfo(idx,state,bm1,bm2,flags);
   form_id.FileListTree._TreeSetInfo(idx,state,bm1,bm2,flags|TREENODE_SELECTED);
   form_id.FileListTree._TreeSetCurIndex(idx);
}


static int get_index_from_tree_user_info(int form_id, int idx)
{
   return form_id.FileListTree._TreeGetUserInfo(idx);
}



static void sync_filename_editbox_with_listbox(boolean select_listbox_item = false)
{
   _str fn = '';
   if (p_active_form.FileListTree._TreeGetNumChildren(TREE_ROOT_INDEX) <= 0) {
      p_active_form.FilenameEditbox.p_text = '';
      return;
   }
   int idx = p_active_form.FileListTree._TreeCurIndex();
   if (idx <= 0) {
      p_active_form.FileListTree._TreeTop();
      idx = p_active_form.FileListTree._TreeCurIndex();
   }
   int line = get_index_from_tree_user_info(p_active_form, idx);
   if (line < 0)
      line = 0;

   if (line >= file_list1._length()) {
      int k = line - file_list1._length();
      if (k < file_list2._length()) {
         fn = file_list2[k];
      }
   }
   else if (file_list1._length() > 0) {
      fn = file_list1[line];
   }
   p_active_form.FilenameEditbox.p_text = fn;
   if (select_listbox_item) {
      select_tree_item(idx, p_active_form);
   }
}

#else
static void sync_filename_editbox_with_listbox(boolean select_listbox_item = false)
{
   _str fn = '';

   int line = p_active_form.FilenameListbox.p_line;
   if (line <= 0)
      line = 1;
   if (line > file_list1._length()) {
      int k = line - file_list1._length() - 1;
      if (k < file_list2._length()) {
         fn = file_list2[k];
      }
   }
   else if (file_list1._length() > 0) {
      fn = file_list1[line - 1];
   }
   p_active_form.FilenameEditbox.p_text = fn;
   if (select_listbox_item) {
      p_active_form.FilenameListbox._lbselect_line();
   }
}
#endif


// This function is the callback for for_each_buffer used
// to populate the file listbox - hence it uses the global variable
// selected_list and is non-static
// file_list1, file_list2, and key_list1 hold the "data" that is used to
// populate the listbox
int Listman_callback_add_open_buffer_to_listbox_data()
{
   // update find_FileList1_item_position if the generation of the information
   // changes

   _str fname = strip_filename(p_buf_name,'DP');
   if (selective_filename_match_string != '') {
      if (pos('/',selective_filename_match_string) == 1) {
         if (pos(substr(selective_filename_match_string,2), fname, 1, 'IR') != 1)
            return 0;
      } else {
         if (pos(selective_filename_match_string, fname, 1, 'I') == 0)
            return 0;
      }
   }

   _str keyn = get_list_item_key(p_buf_name, active_list);
   int flags = global_item_flags;

   if (keyn != '') {
      file_list1[file_list1._length()] = p_buf_name;
      key_list1[key_list1._length()] = keyn;
      flags_list1[flags_list1._length()] = flags;
   }
   else {
      flags_list2[flags_list2._length()] = flags;
      file_list2[file_list2._length()] = p_buf_name;
   }

   return 0;
}


// file_list1, file_list2, and key_list1 hold the "data" that is used to
// populate the listbox
static void add_members_of_selected_list_to_listbox_data()
{
   int k;
   for (k = 0; k < the_lists[selected_list].list_items._length(); ++k) {

      // todo - handle folders, programs, url's etc here - they don't fit path/filename form
      _str fname = the_lists[selected_list].list_items[k].name;
      if (fname != '' && selective_filename_match_string != '') {
         _str fn = strip_filename(fname, 'DP');
         if (pos('/',selective_filename_match_string) == 1) {
            if (pos(substr(selective_filename_match_string,2), fn, 1, 'IR') != 1)
               continue;
         } else {
            if (pos(selective_filename_match_string, fn, 1, 'I') == 0)
               continue;
         }
      }

      if (the_lists[selected_list].list_items[k].key != '') {
         file_list1[file_list1._length()] = fname;
         key_list1[key_list1._length()] = the_lists[selected_list].list_items[k].key;
         flags_list1[flags_list1._length()] = the_lists[selected_list].list_items[k].flags;
      } else if (fname != '') {
         file_list2[file_list2._length()] = fname;
         flags_list2[flags_list2._length()] = the_lists[selected_list].list_items[k].flags;
      }
   }
}

// find_FileList1_item_position returns the "line number" (starting at zero)
// of the item 'name' in the filename listbox by searching file_list1 and file_list2
// For USE_TREE - it returns the tree index
static int find_FileList1_item_position(_str name)
{
   int k;
   for (k = 0; k < file_list1._length(); ++k) {
      if (name :== file_list1[k]) {
         #ifdef USE_TREE
         return tree_item_index_list1[k];
         #else
         return k;
         #endif
      }
   }
   int j;
   for (j = 0; j < file_list2._length(); ++j) {
      if (name :== file_list2[j]) {
         #ifdef USE_TREE
         return tree_item_index_list2[j];
         #else
         return k + j;
         #endif
      }
   }
   return -1;
}


static _str get_FileList1_item_name(int lbline)
{
   if (lbline > file_list1._length()) {
      lbline -= file_list1._length();
      if (lbline > file_list2._length()) {
         global_item_flags = 0;
         return file_list2[file_list2._length() - 1];
      }
      global_item_flags = flags_list2[lbline-1];
      return file_list2[lbline-1];
   }
   global_item_flags = flags_list1[lbline-1];
   return file_list1[lbline - 1];
}


#ifdef USE_TREE

static int get_FileList1_tree_index(int lbline)
{
   if (lbline > tree_item_index_list1._length()) {
      lbline -= tree_item_index_list1._length();
      if (lbline > tree_item_index_list2._length()) {
         return TREE_ROOT_INDEX;
      }
      return tree_item_index_list2[lbline-1];
   }
   return tree_item_index_list1[lbline - 1];
}



// if show_all is false, only filenames with assigned shortcuts are shown
static void populate_filename_listbox(boolean sync_selected_item = true, 
                                      boolean sync_select_first_item = false,
                                      boolean set_focus = true,
                                      boolean populate_others = true, 
                                      boolean show_all = true,
                                      int form_id = p_active_form)
{
   // form_id.FilenameEditbox.p_text is spuriously destroyed by some of the
   // _Tree functions in this code so it has to be saved and restored
   _str save_filename = form_id.FilenameEditbox.p_text;

   if (populate_others) {
      populate_editboxes(form_id);
      form_id.p_caption = get_listman_caption();
      if (list_data_has_been_modified) {
         form_id.SaveListsButton.p_caption = 'Save *';
      } else {
         form_id.SaveListsButton.p_caption = 'Save';
      }
   }
   
   populate_list_names_listbox(form_id);
   form_id.ListNamesListBox._lbdeselect_line();
   form_id.FileListTree._TreeBeginUpdate(TREE_ROOT_INDEX);
   //form_id.FilenameListbox.p_enabled = false;
   file_list1._makeempty();
   file_list2._makeempty();
   key_list1._makeempty();
   flags_list1._makeempty();
   flags_list2._makeempty();
   tree_item_index_list1._makeempty();
   tree_item_index_list2._makeempty();

   selective_filename_match_string = form_id.FileListBoxSelectorCombo.p_text;
   if (selective_filename_match_string != '') {
      form_id.FileListBoxComboLabel.p_backcolor = _rgb(28,255,85);
   } else {
      form_id.FileListBoxComboLabel.p_backcolor = 0x80000005;
      //form_id.FileListBoxSelectorCombo.p_cb_text_box.p_backcolor = _rgb(255,255,255);
   }
   //message(selective_filename_match_string);
   
   switch (filename_listbox_data_type) {
      case LISTBOX_SHOWS_OPEN_BUFFERS :
         _mdi.p_child.for_each_buffer( 'Listman_callback_add_open_buffer_to_listbox_data' );
         break;

      case LISTBOX_SHOWS_SELECTED_LIST : 
      default:
         add_members_of_selected_list_to_listbox_data();
         break;
   }

   // check the find_FileList1_item_position() function if the generation of 
   // the information in this listbox changes

   int k;
   int tree_index;
   _str options, keyname, filename, path, sort_data, fdate;

   for (k = 0; k < file_list1._length(); ++k) {
      
      // todo - handle folders, programs, url's etc here - they don't fit path/filename form

      options = field(convert_flags_to_string_for_file(flags_list1[k]),3);
      fdate = file_date(file_list1[k]) :+ ' ' file_time(file_list1[k]);
      tree_index = -1;

      if ((flags_list1[k] & FFMASK_OPEN_EXTERNALLY) || (selected_list_name == EXTERNAL_LIST_NAME)) {
         keyname = field(key_list1[k],10);
         filename = '  ';
         path = file_list1[k];

      } else {
         keyname = field(key_list1[k],10);
         filename = field(strip_filename(file_list1[k], 'PD'),20);
         path = strip_filename(file_list1[k], 'N');
      }
      switch (filelist_sort_mode) {
         // sort_data goes into a hidden column
         case 1 : sort_data = keyname; break;
         case 2 : sort_data = options; break;
         case 3 : sort_data = filename; break;
         case 4 : sort_data = file_list1[k]; break;
         case 5 : 
            if (file_exists(file_list1[k]))
               sort_data = ' ' :+ _file_date(file_list1[k],'B');
            else
               sort_data = '';
            break;
         default : sort_data = ""; break;
      }
      tree_index = form_id.FileListTree._TreeAddItem(
         TREE_ROOT_INDEX, sort_data :+ "\t " :+ keyname :+ "\t " :+ options :+ "\t " :+ 
            filename :+ "\t ":+ path :+ "\t " :+ fdate, TREE_ADD_AS_CHILD, 0, 0, -1);

      // save the index into flags_list1 (k) in the user info for the tree item
      tree_item_index_list1[k] = tree_index;
      form_id.FileListTree._TreeSetUserInfo(tree_index, k);
      //say( 'x1 ' :+ k :+ ' ' :+ tree_index :+ ' ' :+ filename);
   }
   filename_listbox_total_items = k;
   if (show_all) {
      for (k = 0; k < file_list2._length(); ++k) {

         options = field(convert_flags_to_string_for_file(flags_list2[k]),3);
         fdate = file_date(file_list2[k]) :+ ' ' file_time(file_list2[k]);
         if ((flags_list2[k] & FFMASK_OPEN_EXTERNALLY) || (selected_list_name == EXTERNAL_LIST_NAME)) {
            filename = '  ';
            path = file_list2[k];
         } else {
            filename = field(strip_filename(file_list2[k], 'PD'),20);
            path = strip_filename(file_list2[k], 'N');
         }
         switch (filelist_sort_mode) {
            // sort_data goes into a hidden column
            case 1 : sort_data = "zzzz" :+ filename; break;
            case 2 : sort_data = options; break;
            case 3 : sort_data = filename; break;
            case 4 : sort_data = file_list2[k]; break;
               
            case 5 :
               if (file_exists(file_list2[k]))   // todo when file_list1 is used here, slick crashes
                  sort_data = ' ' :+ _file_date(file_list2[k], 'B');
               else
                  sort_data = '';
               break;
               
            default : sort_data = ""; break;
         }
         tree_index = form_id.FileListTree._TreeAddItem(
            TREE_ROOT_INDEX, sort_data :+ "\t" :+ '         ' :+ "\t " :+ options :+ "\t " :+ 
               filename :+ "\t " :+ path :+ "\t " :+ fdate, TREE_ADD_AS_CHILD, 0, 0, -1);

         // save the index into flags_list2 (k) in the user info for the tree item
         tree_item_index_list2[k] = tree_index;
         form_id.FileListTree._TreeSetUserInfo(tree_index, k + file_list1._length());
         //say( 'x2 ' :+ k :+ ' ' :+ tree_index :+ ' ' :+ filename);
      }
   }

   filename_listbox_total_items += k;

   // TODO for some reason, the next 4 lines of code (all _Tree functions) result 
   // in the content of FilenameEditbox.p_text being spuriously changed, so
   // FilenameEditbox.p_text is restored from save_filename

   _str sop = '';
   if (filelist_sort_order == 1) {
      sop = 'D';
   }
   form_id.FileListTree._TreeSortCaption(TREE_ROOT_INDEX,sop);

   //form_id.FileListTree._TreeSortUserInfo(TREE_ROOT_INDEX,'N');
   form_id.FileListTree._TreeEndUpdate(TREE_ROOT_INDEX);
   form_id.FileListTree._TreeRefresh();
   form_id.FileListTree._TreeTop();

   // see the comment six lines above
   form_id.FilenameEditbox.p_text = save_filename;

   if (sync_select_first_item)
      sync_filename_editbox_with_listbox(true);
   else if (sync_selected_item) {
      show_and_select_file_listbox_item(form_id,form_id.FilenameEditbox.p_text);
   }

   if (set_focus)
      form_id.FileListTree._set_focus();
}


#else
// not USE_TREE

// if show_all is false, only filenames with assigned shortcuts are shown
static void populate_filename_listbox(boolean sync_selected_item = true, 
                                      boolean sync_select_first_item = false,
                                      boolean set_focus = true,
                                      boolean populate_others = true, 
                                      boolean show_all = true,
                                      int form_id = p_active_form)
{
   if (populate_others) 
      populate_editboxes(form_id);
   
   populate_list_names_listbox(form_id);
   form_id.FilenameListbox._lbclear();
   form_id.FilenameListbox.p_enabled = false;
   file_list1._makeempty();
   file_list2._makeempty();
   key_list1._makeempty();
   flags_list1._makeempty();
   flags_list2._makeempty();

   selective_filename_match_string = form_id.FileListBoxSelectorCombo.p_text;
   //message(selective_filename_match_string);
   
   switch (filename_listbox_data_type) {
      case LISTBOX_SHOWS_OPEN_BUFFERS :
         _mdi.p_child.for_each_buffer( 'Listman_callback_add_open_buffer_to_listbox_data' );
         break;

      default: 
      case LISTBOX_SHOWS_SELECTED_LIST : 
         add_members_of_selected_list_to_listbox_data();
         break;
   }

   // check the find_FileList1_item_position() function if the generation of 
   // the information in this listbox changes

   int sp0 = 10;
   int sp1 = 20;
   if (!Listman_global_persistent_data.config.show_filenames_listbox_column_header) {
      if (Listman_global_persistent_data.config.width_col0 < 30)
         sp0 = (int)Listman_global_persistent_data.config.width_col0;
      
      if (Listman_global_persistent_data.config.width_col1 < 60)
         sp1 = (int)Listman_global_persistent_data.config.width_col1;
   }


   int k;
   for (k = 0; k < file_list1._length(); ++k) {
      
      // todo - handle folders, programs, url's etc here - they don't fit path/filename form

      _str options = field(convert_flags_to_string_for_file(flags_list1[k]),3);

      if (Listman_global_persistent_data.config.show_filenames_listbox_column_header) {
         if (flags_list1[k] & FFMASK_OPEN_EXTERNALLY) {
            _str keyname = field(key_list1[k],10) :+ \t;
            _str filename = '  ' :+ \t;
            _str path = file_list1[k];
            form_id.FilenameListbox._lbadd_item(keyname :+ options :+ filename :+ path);
         } else {
            _str keyname = field(key_list1[k],10) :+ \t;
            _str filename = field(strip_filename(file_list1[k], 'PD'),20) :+ \t;
            _str path = strip_filename(file_list1[k], 'N');
            form_id.FilenameListbox._lbadd_item(keyname :+ options :+ filename :+ path);
         }
      } else {
         _str keyname = field(key_list1[k],sp0);
         if (flags_list1[k] & FFMASK_OPEN_EXTERNALLY) {
            _str filename = field(file_list1[k], sp1);
            form_id.FilenameListbox._lbadd_item(keyname :+ options :+ filename);
         } else {
            _str filename = field(strip_filename(file_list1[k], 'PD'),sp1);
            _str path = strip_filename(file_list1[k], 'N');
            form_id.FilenameListbox._lbadd_item(keyname :+ options :+ filename :+ path);
         }
      }
   }
   filename_listbox_total_items = k;
   if (show_all) {
      for (k = 0; k < file_list2._length(); ++k) {

         _str options = field(convert_flags_to_string_for_file(flags_list2[k]),3);

         if (Listman_global_persistent_data.config.show_filenames_listbox_column_header) {
            if (flags_list2[k] & FFMASK_OPEN_EXTERNALLY) {
               _str filename = '  ' :+ \t;
               _str path = file_list2[k];
               form_id.FilenameListbox._lbadd_item('--       ' \t :+ options :+ filename :+ path);
            } else {
               _str filename = field(strip_filename(file_list2[k], 'PD'),20) :+ \t;
               _str path = strip_filename(file_list2[k], 'N');
               form_id.FilenameListbox._lbadd_item('--       ' \t :+ options :+ filename :+ path);
            }
         } else {
            if (flags_list2[k] & FFMASK_OPEN_EXTERNALLY) {
               _str no_key = field('--       ',sp0);
               _str filename = field(file_list2[k], sp1);
               form_id.FilenameListbox._lbadd_item(no_key :+ options :+ filename);
            } else {
               _str no_key = field('--       ',sp0);
               _str filename = field(strip_filename(file_list2[k], 'PD'),sp1);
               _str path = strip_filename(file_list2[k], 'N');
               form_id.FilenameListbox._lbadd_item(no_key :+ options :+ filename :+ path);
            }
         }
      }
   }
   filename_listbox_total_items += k;
   // _col_width can produce horizontal/vertical lines similar to bookmarks toolbar
   //form_id.FilenameListbox._col_width(0,1000);
   //form_id.FilenameListbox._col_width(1,1000);
   //form_id.FilenameListbox._col_width(2,8000);
   form_id.FilenameListbox._lbtop();
   form_id.FilenameListbox.p_enabled = true;

   if (sync_select_first_item)
      sync_filename_editbox_with_listbox(true);
   else if (sync_selected_item) {
      show_and_select_file_listbox_item(form_id,form_id.FilenameEditbox.p_text);
   }

   if (set_focus)
      form_id.FilenameListbox._set_focus();
}


#endif





ListmanForm.on_destroy()
{
   GFM_save_shortcut_lists(listman_datafile_name);
   // update active shortcuts with any changes
   make_list_shortcuts_active(active_list);

   #ifdef USE_TREE
   FileListTree._TreeAppendColButtonWidths();
   #endif

   // Call user-level2 ON_DESTROY so that tool window docking info is saved
   call_event(p_window_id,ON_DESTROY,'2');

}

static int pix2scale(int pix,int form_id)
{
   return _dx2lx(form_id.p_xyscale_mode,pix);
}

static int scale2pix(int scale,int form_id)
{
   return _lx2dx(form_id.p_xyscale_mode,scale);
}


ListmanForm.on_resize()
{
   #ifdef USE_TREE
   #define FileListWidget FileListTree
   #else
   #define FileListWidget FilenameListbox
   #endif

   int height = p_active_form.p_client_height - scale2pix(FileListWidget.p_y, p_active_form) - 34;
   if (height < 100) {
      height = 100;
   }
   FileListWidget.p_height = pix2scale(height, p_active_form);

   int width = p_active_form.p_client_width - scale2pix(FileListWidget.p_x, p_active_form) - 10;
   if (width < 200) {
      width = 200;
   }
   FileListWidget.p_width = pix2scale(width, p_active_form);

   height = p_active_form.p_client_height - scale2pix(ListNamesListBox.p_y, p_active_form) - 34;
   if (height < 100) {
      height = 100;
   }
   ListNamesListBox.p_height = pix2scale(height, p_active_form);

   width = p_active_form.p_client_width - scale2pix(FilenameEditbox.p_x, p_active_form) - 10;
   if (width < 200) {
      width = 200;
   }
   FilenameEditbox.p_width = pix2scale(width, p_active_form);

   width = p_active_form.p_client_width - scale2pix(SelectedListNameEditbox.p_x, p_active_form) - 10;
   if (width < 200) {
      width = 200;
   }
   SelectedListNameEditbox.p_width = pix2scale(width, p_active_form);

   width = p_active_form.p_client_width - scale2pix(ActiveListNameEditBox.p_x, p_active_form) - 10;
   if (width < 200) {
      width = 200;
   }
   ActiveListNameEditBox.p_width = pix2scale(width, p_active_form);

   width = p_active_form.p_client_width - scale2pix(ActiveProjectNameEditbox.p_x, p_active_form) - 10;
   if (width < 200) {
      width = 200;
   }
   ActiveProjectNameEditbox.p_width = pix2scale(width, p_active_form);

   width = p_active_form.p_client_width - scale2pix(FileListBoxSelectorCombo.p_x, p_active_form) - 10;
   if (width < 200) {
      width = 200;
   }
   FileListBoxSelectorCombo.p_width = pix2scale(width, p_active_form);


   ListNamesListBoxComboLabel.p_y = ListNamesListBox.p_y + ListNamesListBox.p_height + pix2scale(8,p_active_form);
   ListNamesListBoxCombo.p_y = ListNamesListBox.p_y + ListNamesListBox.p_height + pix2scale(6,p_active_form);

   FileListBoxComboLabel.p_y = FileListWidget.p_y + FileListWidget.p_height + pix2scale(8,p_active_form);
   FileListBoxSelectorCombo.p_y = FileListWidget.p_y + FileListWidget.p_height + pix2scale(6,p_active_form);

   #undef FileListWidget
}




#ifdef USE_TREE

static void show_and_select_file_listbox_item(int form_id, _str name)
{
   int k = find_FileList1_item_position(name);
   if (k >= 0) 
      select_tree_item(k, form_id);
}


static void filename_listbox_reselect_line(int form_id, int line)
{
   int k = get_FileList1_tree_index(line);
   select_tree_item(k, form_id);
}

#else

static void show_and_select_file_listbox_item(int form_id, _str name)
{
   form_id.FilenameListbox._lbdeselect_line();
   form_id.FilenameListbox._lbtop();

   int k = find_FileList1_item_position(name);
   if (k != -1) {
      while (k--) {
         form_id.FilenameListbox._lbdown();
      }
   }
   form_id.FilenameListbox._lbselect_line();
}

static void filename_listbox_reselect_line(int form_id, int line)
{
   form_id.FilenameListbox._lbdeselect_line();
   form_id.FilenameListbox._lbtop();
   while (--line > 0) {
      form_id.FilenameListbox._lbdown();
   }
   form_id.FilenameListbox._lbselect_line();
}

#endif


static void set_key_binding_mode_inactive(int form_id)
{
   form_id.InfoLabel1.p_caption = 'Click here to bind a key or press C-ENTER';
   form_id.InfoLabel1.p_backcolor = _rgb(255,255,255);

   #ifdef USE_TREE
   form_id.FileListTree._set_focus();
   #else
   form_id.FilenameListbox._set_focus();
   #endif
}


static void set_key_binding_mode_active(int form_id)
{
   #ifdef USE_TREE
   form_id.FileListTree._TreeDeselectAll();
   #else
   form_id.FilenameListbox._lbdeselect_all();
   #endif

   form_id.InfoLabel1.p_caption = 'Press a key twice to bind it or press ESCAPE';
   form_id.InfoLabel1.p_backcolor = _rgb(255,121,255);
   //form_id.InfoLabel1.p_backcolor = _rgb(210,210,255);
   //form_id.InfoLabel1.p_backcolor = _rgb(102,255,101);
}


static void make_the_active_list_the_selected_list(boolean no_new_list = false)
{
   _str pjname = _project_name;
   if (pjname :== '') pjname = 'NoActiveProject';

   // If the active list is valid then set selected list to the active list
   // otherwise set them both to the list for the active project
   if (active_list < 0 || active_list >= the_lists._length() || the_lists[active_list].list_name == '') {
      selected_list = find_listname_index(pjname);
      if (selected_list < 0) {
         if (no_new_list) {
            set_first_list_as_selected();
            make_list_shortcuts_active(-1);
            return;
         } else {
            // create new list for this project
            selected_list = create_new_list(pjname);
         }
      }
      active_list = selected_list;
      make_list_shortcuts_active(active_list);
   } else {
      selected_list = active_list;
   }
   active_list_name = selected_list_name = the_lists[selected_list].list_name;
}


static void check_if_selected_list_is_valid(boolean no_new_list = false)
{
   if (selected_list < 0 || selected_list >= the_lists._length() || the_lists[selected_list].list_name == '') {
      make_the_active_list_the_selected_list(no_new_list);
   } else {
      selected_list_name = the_lists[selected_list].list_name;
   }
}


static _str get_listman_caption()
{
   return 'Listman:  ' :+ 
      strip_filename(listman_datafile_name,'PD') :+ '  ' :+ strip_filename(listman_datafile_name,'N');
}


ListmanForm.on_create()
{
   int fmid = p_active_form;
   ListNamesListBox.p_font_name = Listman_global_persistent_data.config.listnames_fontname;
   ListNamesListBox.p_font_size = Listman_global_persistent_data.config.listnames_font_size;
   #ifdef USE_TREE
   FileListTree.p_font_name = Listman_global_persistent_data.config.filenames_fontname;
   FileListTree.p_font_size = Listman_global_persistent_data.config.filenames_font_size;
   FileListTree.p_enabled = true;
   FileListTree.p_visible = true;
   FileListTree.p_y = 3420;
   FilenameListbox.p_visible = false;
   FilenameListbox.p_enabled = false;
   #else
   FilenameListbox.p_font_name = Listman_global_persistent_data.config.filenames_fontname;
   FilenameListbox.p_font_size = Listman_global_persistent_data.config.filenames_font_size;
   FileListTree.p_enabled = false;
   FileListTree.p_visible = false;
   FilenameListbox.p_enabled = true;
   FilenameListbox.p_y = 3420;
   FilenameListbox.p_visible = true;
   #endif

   ListNamesListBox.p_pic_point_scale = 0;   
   ListNamesListBox.p_picture = pic_index_col1_active_file;
   ListNamesListBox.p_stretch = 0;
   ListNamesListBox.p_auto_size = false;
   p_active_form.p_caption = get_listman_caption(); 
   GFM_load_shortcut_list_data(listman_datafile_name);
   check_if_selected_list_is_valid();
   check_and_create_default_lists();
   set_key_binding_mode_inactive(fmid);
   // None of the _lb functions cause an on change event - the help says so! (applies to listbox - USE_TREE undef'd)
   set_radio_button(last_radio_button_selected, fmid);
   SwitchOnNewProjectCheckBtn.p_value = switch_list_on_project_switch;

}


static int ListmanForm_show_and_setpos()
{
   show('-XY ListmanForm');
   int form_id = _find_formobj('ListmanForm');
   if (form_id == 0) {
      message('Form ListmanForm not found.');
      return 0;
   }
   set_key_binding_mode_inactive(form_id);
   set_radio_button(last_radio_button_selected, form_id);
   // None of the _lb functions cause an on change event - the help says so!
   return form_id;
}


static void run_key_binding(int form_id)
{
   boolean first_key = true;
   _str last_key = '';

   #ifdef USE_TREE
   form_id.FileListTree._TreeDeselectAll();
   #else
   form_id.FilenameListbox._lbdeselect_line();
   #endif
   set_key_binding_mode_active(form_id);

   while (true) {
      _str key = get_event('N');   // refresh screen and get a key
      _str keyt = event2name(key);
      switch (keyt) {
         case 'ESC' :
         case 'LBUTTON-DOWN' :
         case 'RBUTTON-DOWN' :
            show_and_select_file_listbox_item(form_id,form_id.FilenameEditbox.p_text);
            #ifdef USE_TREE
            form_id.FileListTree._set_focus();
            #else
            form_id.FilenameListbox._set_focus();
            #endif
            set_key_binding_mode_inactive(form_id);
            return;
         default:
            if (length(keyt) > 9)
               break;  // ignore mouse buttons
            
            if (first_key || (last_key != keyt)) {
               first_key = false;
               form_id.InfoLabel1.p_caption = ' Repeat key: ' :+ keyt;
               last_key = keyt;
            } else {
               // if showing open buffers or project, then key binding goes
               // to the active list - in this case, selected_list is the
               // same value as active_list.
               add_item_to_list(selected_list, keyt, form_id.FilenameEditbox.p_text);
               populate_filename_listbox(true, false, true, true, true, form_id);
               set_key_binding_mode_inactive(form_id);
               return;
            }
            break;
      }
   }
}



UnbindButton.lbutton_up()
{
   remove_key_from_list(selected_list, p_active_form.FilenameEditbox.p_text);
   populate_filename_listbox();
   //set_key_binding_mode_inactive(p_active_form);
}


InfoLabel1.lbutton_up()
{
   run_key_binding(p_active_form);
}


#ifdef USE_TREE
FileListTree.on_create()
{
   if (Listman_global_persistent_data.config.allow_resize_tree_col0) {
      FileListTree._TreeSetColButtonInfo(0,300,TREE_BUTTON_PUSHBUTTON,0,"");
   }
   else {
      FileListTree._TreeSetColButtonInfo(0,1,TREE_BUTTON_PUSHBUTTON|TREE_BUTTON_FIXED_WIDTH,0,"");
   }
   FileListTree._TreeSetColButtonInfo(1,1000,TREE_BUTTON_PUSHBUTTON,0,"Key");
   FileListTree._TreeSetColButtonInfo(2,500,TREE_BUTTON_PUSHBUTTON,0,"Flags");
   FileListTree._TreeSetColButtonInfo(3,2000,TREE_BUTTON_PUSHBUTTON,0,"Name");
   FileListTree._TreeSetColButtonInfo(4,5000,TREE_BUTTON_PUSHBUTTON,0,"Path");
   FileListTree._TreeSetColButtonInfo(5,2000,TREE_BUTTON_PUSHBUTTON,0,"Date");

   FileListTree._TreeRetrieveColButtonWidths();
   //FileListTree._TreeSortCaption(TREE_ROOT_INDEX,'D','F');
}

#else
FilenameListbox.on_create()
{
   //_col_width(0,1000);
   //_col_width(1,1000);
   //_col_width(2,8000);

   if (Listman_global_persistent_data.config.show_filenames_listbox_column_header) {
      _SetListColInfo(0,(int)Listman_global_persistent_data.config.width_col0,LBCOLSTYLE_LABEL); 
      _SetListColCaption(0,"Shortcut");
      _SetListColInfo(1,(int)Listman_global_persistent_data.config.width_col1,LBCOLSTYLE_2STATE,0);
      _SetListColCaption(1,"Name");
      _SetListColInfo(2,8000,LBCOLSTYLE_2STATE,0);
      _SetListColCaption(2,"Path");
   }
}
#endif




#ifdef USE_TREE
static void for_each_selected_filelist_item(int(*pfn)(int))
{
   int fmid = p_active_form;
   int y = -1;
   int idx = fmid.FileListTree._TreeFindSelected(1);
   while (idx >= 0) {
      int fx = get_index_from_tree_user_info(fmid,idx);
      if (fx >= 0) {
         if (y == -1) {
            y = fmid.FileListTree._TreeCurLineNumber();
         }
         // execute the callback function
         (*pfn)(fx + 1);
      }
      idx = fmid.FileListTree._TreeFindSelected(0);
   }

   if (y != -1) {
      // check the Listman form didn't die during the callback
      fmid = _find_formobj('ListmanForm');
      if (fmid == 0) return; 
      populate_filename_listbox(false, false, true, true, true, fmid);
      if (filename_listbox_total_items == 0) {
         fmid.FilenameEditbox.p_text = '';
         return;
      }
      if (y >= filename_listbox_total_items) --y;
      if (y < 0) y = 0;
      //say(' y = ' :+ y);

      // TODO for some reason, the content of fmid.FilenameEditbox.p_text can spuriously
      // change during the call to _TreeCurLineNumber in the next line
      fmid.FileListTree._TreeCurLineNumber(y);

      select_tree_item(fmid.FileListTree._TreeCurIndex(), fmid);
      int ln = get_index_from_tree_user_info(fmid, fmid.FileListTree._TreeCurIndex());
      fmid.FilenameEditbox.p_text = get_FileList1_item_name(ln+1);
   }
}

#else

static void for_each_selected_filelist_item(int(*pfn)(int))
{
   int fmid = p_active_form;
   if (fmid.FilenameListbox.p_Nofselected > 0) {
      fmid.FilenameListbox.p_enabled = false;
      int k, y;
      y = -1;
      for (k = 1; k <= filename_listbox_total_items; ++k) {
         fmid.FilenameListbox.p_line = k;
         if (fmid.FilenameListbox._lbisline_selected()) {
            if (y == -1) y = k;
            (*pfn)(k);
         }
      }
      // check the Listman form didn't die during the callback
      fmid = _find_formobj('ListmanForm');
      if (fmid == 0) return; 
      populate_filename_listbox(false, false, true, true, true, fmid);
      fmid.FilenameListbox.p_enabled = true;
      if (filename_listbox_total_items == 0) {
         fmid.FilenameEditbox.p_text = '';
         return;
      }
      if (y > filename_listbox_total_items) --y;
      if (y < 1) y = 1;
      filename_listbox_reselect_line(fmid,y);
      fmid.FilenameEditbox.p_text = get_FileList1_item_name(y);
   }
}
#endif

static int callback_remove_key_from_list(int k)
{
   remove_key_from_list(selected_list, get_FileList1_item_name(k));
   return 0;
}


static int callback_remove_item_from_list(int k)
{
   remove_item_from_list(selected_list, get_FileList1_item_name(k));
   return 0;
}


static int callback_open_selected_item(int k)
{
   _str name = get_FileList1_item_name(k);
   if ( (global_item_flags & FFMASK_OPEN_EXTERNALLY) || 
        (selected_list_name == EXTERNAL_LIST_NAME) ) {
      open_external_item(name);
   } else if (pos('.',name) == 1) {
      edit('+B ' name);
   } else {
      edit(maybe_quote_filename(name));
   }
   return 0;
}



#ifdef USE_TREE

// DEL - unbind the shortcut from the filename
FileListTree.'DEL'()
{
   for_each_selected_filelist_item(callback_remove_key_from_list);
}

// Shift DEL - delete the filename from the list
FileListTree.'S-DEL'()
{
   for_each_selected_filelist_item(callback_remove_item_from_list);
}


FileListTree.'C-ENTER'()
{
   run_key_binding(p_active_form);
}


// ENTER is open files and destroy listman dialog
FileListTree.'ENTER'()
{
   for_each_selected_filelist_item(callback_open_selected_item);
   int form_id = _find_formobj('ListmanForm');
   if (form_id != 0) 
      form_id._delete_window('');
}


// C-S-ENTER is open files but listman dialog stays alive
FileListTree.'C-S-ENTER'()
{
   for_each_selected_filelist_item(callback_open_selected_item);
   int form_id = _find_formobj('ListmanForm');
   if (form_id != 0) 
      form_id.FileListTree._set_focus();
}


static int target_list_index_for_item_copy;

static int callback_copy_item_to_list(int k)
{
   if (k > file_list1._length()) {
      k -= file_list1._length();
      if (--k >= file_list2._length()) {
         return 0;
      }
      add_item_to_list(target_list_index_for_item_copy, '', file_list2[k], flags_list2[k] );
      return 0;
   }
   if (--k < 0) {
      return 0;
   }
   add_item_to_list(target_list_index_for_item_copy, key_list1[k], file_list1[k], flags_list1[k] );
   return 0;
}


/*
version 11
FileListTree.on_change(typeless reason, int index)
{
   // When CHANGE_BUTTON_PRESS event occurs, three recursive CHANGE_SELECTED events
   // occur before the CHANGE_BUTTON_PRESS event call completes, as shown by
   // uncommenting debug code here.
   // The call to sync_filename_editbox_with_listbox should pass false as the
   // argument, otherwise even more recursion (perhaps infinite) might occur.
   
   //static int ch;
   //++ch;
   //say(' ch ' :+ ch);
   if (reason == CHANGE_SELECTED) {
      //say(' chs ' :+ ch);
      sync_filename_editbox_with_listbox(false);
   }
   else if (reason == CHANGE_BUTTON_PRESS) {
      //say(' chbp ' :+ ch);
      if (filelist_sort_mode == index) {
         filelist_sort_order = (filelist_sort_order==1 ? 0 : 1);
      } else {
         filelist_sort_mode = index;
         filelist_sort_order = 0;
      }
      populate_filename_listbox(true, false, true, true, true, p_active_form);
   }
   //say(' ch2 ' :+ ch);
}

*/

FileListTree.on_change(typeless reason, int index, int col=-1)
{
   // When CHANGE_BUTTON_PRESS event occurs, three recursive CHANGE_SELECTED events
   // occur before the CHANGE_BUTTON_PRESS event call completes, as shown by
   // uncommenting debug code here.
   // The call to sync_filename_editbox_with_listbox should pass false as the
   // argument, otherwise even more recursion (perhaps infinite) might occur.
   
   //static int ch;
   //++ch;
   //say(' ch ' :+ ch);
   if (reason == CHANGE_SELECTED) {
      //say(' chs ' :+ ch);
      sync_filename_editbox_with_listbox(false);
   }
   else if (reason == CHANGE_BUTTON_PRESS) {
      //say(' chbp ' :+ ch);
      if (filelist_sort_mode == col) {
         filelist_sort_order = (filelist_sort_order==1 ? 0 : 1);
      } else {
         filelist_sort_mode = col;
         filelist_sort_order = 0;
      }
      //say(col);
      populate_filename_listbox(true, false, true, true, true, p_active_form);
   }
   //say(' ch2 ' :+ ch);
}


#else
// DEL - unbind the shortcut from the filename
FilenameListbox.'DEL'()
{
   for_each_selected_filelist_item(callback_remove_key_from_list);
}

// Shift DEL - delete the filename from the list
FilenameListbox.'S-DEL'()
{
   for_each_selected_filelist_item(callback_remove_item_from_list);
}


FilenameListbox.'C-ENTER'()
{
   run_key_binding(p_active_form);
}


// ENTER is open files and destroy listman dialog
FilenameListbox.'ENTER'()
{
   for_each_selected_filelist_item(callback_open_selected_item);
   int form_id = _find_formobj('ListmanForm');
   if (form_id != 0) 
      form_id._delete_window('');
}


// C-S-ENTER is open files but listman dialog stays alive
FilenameListbox.'C-S-ENTER'()
{
   for_each_selected_filelist_item(callback_open_selected_item);
   int form_id = _find_formobj('ListmanForm');
   if (form_id != 0) 
      form_id.FilenameListbox._set_focus();
}


FilenameListbox.on_change(typeless reason)
{
   if (reason == CHANGE_SELECTED) {
      sync_filename_editbox_with_listbox(false);
   }
   else {
      //void _GetListColInfo(int index,int &width,int &flags=0,int &state=0);
      if (Listman_global_persistent_data.config.show_filenames_listbox_column_header) {
         int cwidth0, cwidth1, cflags, cstate;
         _GetListColInfo(0, cwidth0, cflags, cstate);
         _GetListColInfo(1, cwidth1, cflags, cstate);
         ListmanSaveColWidths(cwidth0, cwidth1);
      }
   }
}


#endif


UnbindButton.lbutton_up()
{
   for_each_selected_filelist_item(callback_remove_key_from_list);
}


RemoveFilesButton.lbutton_up()
{
   for_each_selected_filelist_item(callback_remove_item_from_list);
}



static void open_external_item(_str item)
{
   _str cfg = strip(_config_path(),'t',FILESEP);
   _str file = strip(item,'t',FILESEP);

   // 'Q' option is needed to avoid command shell window in Win XP
   // To run a batch file instead of .exe, the 'Q' option must not be used
   //shell('"' :+ _config_path() :+ 'gp1.bat" ' :+ 
     //          '"' p_active_form.FilenameEditbox.p_text '" ' :+ '"'_config_path() '"', 'PA');
   shell('"' :+ _config_path() :+ 'listman_open_external.exe" ' :+ 
               '"' file '" ' :+ '"' cfg '"', 'QPA');

}




#ifndef USE_TREE
FileListTree.on_create()
{
   FileListTree._TreeSetColButtonInfo(0,1000,TREE_BUTTON_PUSHBUTTON|TREE_BUTTON_SORT,0,"Name");
   FileListTree._TreeSetColButtonInfo(1,1000,TREE_BUTTON_PUSHBUTTON|TREE_BUTTON_SORT,0,"Name2");
}
#endif



static void set_radio_button(int which, int wid = p_active_form)
{
   // setting the p_value property of a radio button generates an lbutton_up
   // event for the radio button, which does the work
   switch (which) {
      case LISTBOX_SHOWS_OPEN_BUFFERS : wid.OpenBuffersRadioButton.p_value = 1; return;
      case LISTBOX_SHOWS_SELECTED_LIST : wid.SelectedListRadioButton.p_value = 1; return;
      case LISTBOX_SHOWS_FAVORITES : wid.FavoritesRadioButton.p_value = 1; return;
      case LISTBOX_SHOWS_EXTERNAL : wid.ExternalRadioButton.p_value = 1; return;
   }
}


ListmanForm.'F1'()
{
   set_radio_button(LISTBOX_SHOWS_OPEN_BUFFERS);
}

ListmanForm.'F3'()
{
   set_radio_button(LISTBOX_SHOWS_SELECTED_LIST);
}

ListmanForm.'F4'()
{
   set_radio_button(LISTBOX_SHOWS_FAVORITES);
}

ListmanForm.'F5'()
{
   set_radio_button(LISTBOX_SHOWS_EXTERNAL);
}


ListmanForm.'F12'()
{
   FileListBoxSelectorCombo._set_focus();
}

FileListBoxSelectorCombo.on_lost_focus()
{
   sel_combo_has_focus = false;
}


FileListBoxSelectorCombo.on_got_focus()
{
   sel_combo_has_focus = true;
}


ListmanForm.'C-Down'()
{
   int k = p_active_form.ListNamesListBox.p_line;
   if (k >= listnames_listbox_index._length() || k < 0) 
      return 0;

   k = listnames_listbox_index[k];
   if (k <= the_lists._length() && k >= 0) {
      selected_list = k;
      selected_list_name = the_lists[selected_list].list_name;
      set_radio_button(LISTBOX_SHOWS_SELECTED_LIST);
   }
}

ListmanForm.'C-UP'()
{
   int k = p_active_form.ListNamesListBox.p_line;
   if (k > listnames_listbox_index._length() || k < 2) 
      return 0;

   k = listnames_listbox_index[k - 2];
   if (k <= the_lists._length() && k >= 0) {
      selected_list = k;
      selected_list_name = the_lists[selected_list].list_name;
      set_radio_button(LISTBOX_SHOWS_SELECTED_LIST);
   }
}


OpenBuffersRadioButton.lbutton_up()
{
   // when open buffers are shown, the active list becomes the selected list
   // so the file list shows the active key bindings and so that new key bindings 
   // go to the active list
   last_radio_button_selected = LISTBOX_SHOWS_OPEN_BUFFERS;
   filename_listbox_data_type = LISTBOX_SHOWS_OPEN_BUFFERS;
   make_the_active_list_the_selected_list();
   populate_filename_listbox(false, true);
}


SelectedListRadioButton.lbutton_up()
{
   last_radio_button_selected = LISTBOX_SHOWS_SELECTED_LIST;
   filename_listbox_data_type = LISTBOX_SHOWS_SELECTED_LIST;
   //make_the_active_list_the_selected_list(true);
   populate_filename_listbox(false, true);
}


FavoritesRadioButton.lbutton_up()
{
   last_radio_button_selected = LISTBOX_SHOWS_FAVORITES;
   int k = find_listname_index(FAVORITES_LIST_NAME);
   if (k < 0)
      return 0;

   selected_list = k;
   selected_list_name = the_lists[selected_list].list_name;

   filename_listbox_data_type = LISTBOX_SHOWS_SELECTED_LIST;
   populate_filename_listbox(false, true);
}


ExternalRadioButton.lbutton_up()
{
   last_radio_button_selected = LISTBOX_SHOWS_EXTERNAL;
   int k = find_listname_index(EXTERNAL_LIST_NAME);
   if (k < 0) return 0;
   selected_list = k;
   selected_list_name = the_lists[selected_list].list_name;
   filename_listbox_data_type = LISTBOX_SHOWS_SELECTED_LIST;
   populate_filename_listbox(false, true);
}


FileListBoxSelectorCombo.on_change()
{
   populate_filename_listbox(false, true, false);
}


int add_open_buffer_to_list()
{
   add_item_to_list(selected_list,'',p_buf_name);
   return 0;
}


static _str all_buffers[];

int listman_for_each_buffer()
{
   all_buffers[all_buffers._length()] = p_buf_name;
   return 0;
}

static void listman_get_all_buffers()
{
   all_buffers._makeempty();
   for_each_buffer('listman_for_each_buffer');
}


OpenAllFilesButton.lbutton_up()
{
   int wid = p_window_id;

   int result = textBoxDialog("Load list files", // Form caption
                              TB_RETRIEVE,      // Flags
                              0,                // Use default textbox width
                              "",               // Help item
                              "",
                              "ListmanLoadList",  // Retrieve Name
                              "List name:"selected_list_name, 
                              "-CHECKBOX Close all open buffers first:"1,
                              "-CHECKBOX Make list shortcuts active:"1);
   if (result != COMMAND_CANCELLED_RC) {
      int k = find_listname_index(_param1);
      if (k < 0) {
         _message_box('List ' :+ _param1 :+ ' not found.');
         return 0;
      }

      int z = the_lists[k].list_items._length();
      if (z <= 0) {
         _message_box('List ' :+ _param1 :+ ' is empty.');
         return 0;
      }

      // open the first file in the new list so that we don't delete all buffers
      // - otherwise the window size can change.  Even without this problem,
      // calling close_all doesn't work here - it closes the listman dialog.

      _str first_file;
      int y;   
      for (y = 0; y < z; ++y) {
         if (!(the_lists[k].list_items[y].flags & FFMASK_OPEN_EXTERNALLY)) {
            first_file = the_lists[k].list_items[0].name;
            edit(maybe_quote_filename(first_file));
            break;
         }
      }

      if (_param2) {
         listman_get_all_buffers();
         int k2;
         for (k2 = 0; k2 < (all_buffers._length()-1); ++k2) {
            if (first_file != all_buffers[k2]) {
               _save_non_active(all_buffers[k2],1);
            }
         }
      }

      if (_param3) {
         make_list_shortcuts_active(k);
      }

      for (; y < z; ++y) {
         if (!(the_lists[k].list_items[y].flags & FFMASK_OPEN_EXTERNALLY)) 
            edit(maybe_quote_filename(the_lists[k].list_items[y].name));
      }
      int form_id = _find_formobj('ListmanForm');
      if (form_id == 0) {
         form_id = show('-XY ListmanForm');
         //message('Form ListmanForm not found.');
         //return 0;
      }
      set_radio_button(LISTBOX_SHOWS_OPEN_BUFFERS, form_id);
   }
}


SetListActiveButton.lbutton_up()
{
   make_list_shortcuts_active(selected_list);
   set_radio_button(LISTBOX_SHOWS_SELECTED_LIST);
}


NewListButton.lbutton_up()
{
   int result = textBoxDialog("Create new list", // Form caption
                              TB_RETRIEVE,      // Flags
                              0,                // Use default textbox width
                              "",               // Help item
                              "",
                              "ListmanCreateNewList",  // Retrieve Name
                              "Enter list name", "-CHECKBOX Add all open buffers:"1);
   if (result != COMMAND_CANCELLED_RC) {
      if (find_listname_index(_param1) >= 0) {
         _message_box('List ' :+ _param1 :+ ' is already present.');
         return 0;
      }
      selected_list = create_new_list(_param1);
      selected_list_name = _param1;
      if (_param2) 
         for_each_buffer('add_open_buffer_to_list');
      
      set_radio_button(LISTBOX_SHOWS_SELECTED_LIST);
   }

}

ListNamesListBox.on_change(typeless reason, int index = 2345)
{
   int form_id = p_active_form;
   if (reason == CHANGE_SELECTED) {
      int k = p_line - 1;
      if (k < 0 || k >= listnames_listbox_index._length()) {
         return 0;
      }
      k = listnames_listbox_index[k];
      if (k <= the_lists._length() && k >= 0) {
         selected_list = k;
         selected_list_name = the_lists[selected_list].list_name;
         set_radio_button(LISTBOX_SHOWS_SELECTED_LIST);
         //form_id.ListNamesListBox._lbselect_line();
         // Deselect all the items in the tree
         //form_id.FileListTree._TreeSetAllFlags(0,TREENODE_SELECTED);
         //form_id.ListNamesListBox._set_focus();
      }
   }
   else if (reason == CHANGE_BUTTON_PRESS) {
   }
}


FileListTree.'A-DOWN'()
{
   _TreeDown();
   select_tree_item(_TreeCurIndex());
}

FileListTree.'A-UP'()
{
   _TreeUp();
   select_tree_item(_TreeCurIndex());
}



static int Listman_switch_data_files()
{
   int form_id = p_active_form;
   _str result=_OpenDialog("-modal "_stdform("_open_form"), 
      "Select data file", // Title
      "", // Initial wildcards
      '',
      0,//  OFN_NOCHANGEDIR,
      "", // Default extension
      "", // Initial filename
      LIST_DATA_FOLDER_PATH, // Initial directory
      "",
      "");
   if( result=="" ) {
      // User cancelled the dialog
      return 0;
   }

   if (active_list != -1 && !(the_lists[active_list].list_flags & LFMASK_LIST_IS_GLOBAL)) {
      active_list_name = '';
      active_list = -1;
   }
   GFM_save_shortcut_lists(listman_datafile_name);
   GFM_load_shortcut_list_data(result);

   if (active_list_name != '') {
      // the active list was global so need to find its (new) index
      make_list_shortcuts_active(find_listname_index(active_list_name));
   } else {
      make_list_shortcuts_active(find_listname_index(_project_name));
   }
   make_the_active_list_the_selected_list(true);

   populate_filename_listbox(false, true, true, true, true, form_id);
   return 0;
}



void ListnamesMoreButton.lbutton_up()
{
   menu_save_active_form_id = p_active_form;
   int index=find_index("ListmanListnamesButtonMenu",oi2type(OI_MENU));
   if (!index) {
      return;
   }
   int menu_handle=p_active_form._menu_load(index,'P');

   message(selected_list_name);

   // build the menu

   if (the_lists[selected_list].list_flags & LFMASK_LIST_IS_GLOBAL) {
      _menu_insert(menu_handle, -1, MF_ENABLED, "Make selected list non-&Global",
         "Listman_toggle_list_global_status","","", selected_list_name ); 
   } else {
      _menu_insert(menu_handle, -1, MF_ENABLED, "Make selected list &Global",
         "Listman_toggle_list_global_status","","", selected_list_name ); 
   }

   _menu_insert(menu_handle, -1, MF_ENABLED, "&Delete selected list",
      "Listman_delete_selected_list","","", selected_list_name ); 

   _menu_insert(menu_handle, -1, MF_ENABLED, "&Rename selected list",
      "Listman_rename_selected_list","","", selected_list_name ); 

   // Show the menu.
   int x =100;
   int y=100;
   x=mou_last_x('M')-x;y=mou_last_y('M')-y;
   _lxy2dxy(p_scale_mode,x,y);
   _map_xy(p_window_id,0,x,y,SM_PIXEL);
   int flags=VPM_LEFTALIGN|VPM_RIGHTBUTTON;
   int status=_menu_show(menu_handle,flags,x,y);
   _menu_destroy(menu_handle);
}


void CopyListButton.lbutton_up()
{
   copy_selected_list();
}


SaveListsButton.lbutton_up()
{
   GFM_save_shortcut_lists(listman_datafile_name, true);
   populate_filename_listbox(true);
}


SwitchMasterButton.lbutton_up()
{
   Listman_switch_data_files();
}

_command int ListmanAddFiles()
{
   _str result=_OpenDialog("-modal "_stdform("_open_form"), 
      "Add files to list " :+ selected_list_name, // Title
      "", // Initial wildcards
      def_file_types,
      OFN_NOCHANGEDIR|OFN_FILEMUSTEXIST|OFN_ALLOWMULTISELECT,
      "", // Default extension
      "", // Initial filename
      "", // Initial directory
      "",
      "");
   message(result);
   //result=strip(result,'B','"');
   if( result=="" ) {
      // User cancelled the dialog
      return 0;
   }
   _str fn;
   int flags;
   while (result != '') {
      fn = parse_file(result,false);
      if (file_extension_might_be_external(get_extension(fn)))
         flags = FFMASK_OPEN_EXTERNALLY;
      else
         flags = 0;

      add_item_to_list(selected_list,'',fn, flags);
   }
   set_radio_button(LISTBOX_SHOWS_SELECTED_LIST);
   return 0;
}


_command void ListmanAddItem()
{
   int result = textBoxDialog("Add item to list", // Form caption
                              TB_RETRIEVE,      // Flags
                              0,                // Use default textbox width
                              "",               // Help item
                              "",
                              "ListmanAddItem",  // Retrieve Name
                              "Enter text for item to be added");
   if (result != COMMAND_CANCELLED_RC) {
      add_item_to_list(selected_list,'',_param1, FFMASK_OPEN_EXTERNALLY);
   }
   set_radio_button(LISTBOX_SHOWS_SELECTED_LIST);
   return;
}


AddItemsButton.lbutton_up()
{
   menu_save_active_form_id = p_active_form;
   int index=find_index("ListmanAddItemsMenu",oi2type(OI_MENU));
   if (!index) {
      return 0;
   }
   int menu_handle=p_active_form._menu_load(index,'P');

   // build the menu

   _menu_insert(menu_handle, -1, MF_ENABLED, "Add &files",
      "ListmanAddFiles","","", ""); 

   _menu_insert(menu_handle, -1, MF_ENABLED, "Add &item",
      "ListmanAddItem","","", ""); 

   // Show the menu.
   int x =100;
   int y=100;
   x=mou_last_x('M')-x;y=mou_last_y('M')-y;
   _lxy2dxy(p_scale_mode,x,y);
   _map_xy(p_window_id,0,x,y,SM_PIXEL);
   int flags=VPM_LEFTALIGN|VPM_RIGHTBUTTON;
   int status=_menu_show(menu_handle,flags,x,y);
   _menu_destroy(menu_handle);
   return 0;
}



// callback_flags could be passed as a parameter but why bother, this is single
// user/ single thread code.
static int callback_flags;
static int callback_set_list_item_options(int k)
{
   set_list_item_options(selected_list, get_FileList1_item_name(k), callback_flags);
   return 0;
}


_command void Listman_set_item_external_option()
{
   int result = textBoxDialog("Set options for files", // Form caption
                              TB_RETRIEVE,      // Flags
                              0,                // Use default textbox width
                              "",               // Help item
                              "",
                              "ListmanOptionsForFiles",  // Retrieve Name
                              "-CHECKBOX Open selected files externally :"1);
   if (result != COMMAND_CANCELLED_RC) {
      callback_flags = 0;
      if (_param1) 
         callback_flags = FFMASK_OPEN_EXTERNALLY;
      for_each_selected_filelist_item(callback_set_list_item_options);
   }
}


_command void Listman_copy_items()
{
   int result = textBoxDialog("Copy items to list", // Form caption
                              TB_RETRIEVE,      // Flags
                              0,                // Use default textbox width
                              "",               // Help item
                              "",
                              "ListmanCopyItems",  // Retrieve Name
                              "Enter list name to copy selected items to");
   if (result != COMMAND_CANCELLED_RC) {
      target_list_index_for_item_copy = find_listname_index(_param1);
      if (target_list_index_for_item_copy < 0) {
         target_list_index_for_item_copy = create_new_list(_param1);
      }
      for_each_selected_filelist_item(callback_copy_item_to_list);
   }
}


FileListTree.'C-C'()
{
   Listman_copy_items();
}


FilelistMoreButton.lbutton_up()
{
   menu_save_active_form_id = p_active_form;
   int index=find_index("ListmanFilelistMoreButtonMenu",oi2type(OI_MENU));
   if (!index) {
      return 0;
   }
   int menu_handle=p_active_form._menu_load(index,'P');

   // build the menu

   _menu_insert(menu_handle, -1, MF_ENABLED, "&Copy selected items",
      "Listman_copy_items","","", selected_list_name ); 

   _menu_insert(menu_handle, -1, MF_ENABLED, '&Set/unset item "open external" option',
      "Listman_set_item_external_option","","", selected_list_name ); 

   // Show the menu.
   int x =100;
   int y=100;
   x=mou_last_x('M')-x;y=mou_last_y('M')-y;
   _lxy2dxy(p_scale_mode,x,y);
   _map_xy(p_window_id,0,x,y,SM_PIXEL);
   int flags=VPM_LEFTALIGN|VPM_RIGHTBUTTON;
   int status=_menu_show(menu_handle,flags,x,y);
   _menu_destroy(menu_handle);
   return 0;
}



_command void GFM_two_key_check_shortcut_keys() name_info(',')
{
   _str last = event2name(last_event());
   call_list('_listman_key1');
   while (true) {
      _str key = get_event('N');   // refresh screen and get a key
      _str keyt = event2name(key);
      call_list('_listman_key2', keyt);
      if (keyt :== last) {
         ListmanForm_show_and_setpos();
         return;
      }
      else {
         _str fname = lookup_active_shortcut_key_list(keyt);
         if (fname != '') {
            if (last_looked_up_active_shortcut_item.flags & FFMASK_OPEN_EXTERNALLY) {
               open_external_item(fname);
            } else {
               edit(maybe_quote_filename(fname));
            }
         }
         return;
      }
   }
}

_command void ListmanReceiveExternalCommandName(...) name_info('VSARG2_CMDLINE,')
{
   say('hi');
   if (arg() > 0) {
      say(arg(1));
   }
}


int listman_get_active_list_num_items()
{
   if (active_list >= 0 && active_list < the_lists._length()) {
      return the_lists[active_list].list_items._length();
   }
   return 0;
}

_str listman_get_active_list_item_name(int item)
{
   if (active_list < 0 || active_list >= the_lists._length()) 
      return '';

   if (item < listman_get_active_list_num_items()) {
      return the_lists[active_list].list_items[item].name;
   }
   return '';
}


_str listman_get_active_list_item_key(int item)
{
   if (active_list < 0 || active_list >= the_lists._length()) 
      return '';

   if (item < listman_get_active_list_num_items()) {
      return the_lists[active_list].list_items[item].key;
   }
   return '';
}


void listman_generate_active_shortcuts_list(listman_shortcuts_item (&result)[], boolean include_external)
{
   typeless k;
   _str temp[];
   int j=0;
   int count = 0;
   temp._makeempty();
   result._makeempty();
   for (k._makeempty();;) {
      active_shortcut_list._nextel(k);
      if (k._isempty()) {
         break;
      }
      if (include_external || !(active_shortcut_list:[k].flags & FFMASK_OPEN_EXTERNALLY)) {
         temp[j++] = active_shortcut_list:[k].name :+ '#@?' :+ k; 
      }
   }
   temp._sort();
   int m,r;
   _str s1, s2;
   for (m = 0, r = 0; m < j; m++, r++) {
      parse temp[m] with result[r].name '#@?' result[r].key;
   }
}


_str listman_get_active_list_name()
{
   return active_list_name;
}


SwitchOnNewProjectCheckBtn.lbutton_up()
{
   switch_list_on_project_switch = SwitchOnNewProjectCheckBtn.p_value;
}


ConfigButton.lbutton_up()
{
   show('-XY ListmanConfigForm');
}

void ListmanProcessNewConfig()
{
   int form_id = ListmanForm_show_and_setpos();
   if (form_id == 0) {
      return;
   }
   form_id.ListNamesListBox.p_font_name = Listman_global_persistent_data.config.listnames_fontname;
   form_id.ListNamesListBox.p_font_size = Listman_global_persistent_data.config.listnames_font_size;

   #ifdef USE_TREE
   form_id.FileListTree.p_font_name = Listman_global_persistent_data.config.filenames_fontname;
   form_id.FileListTree.p_font_size = Listman_global_persistent_data.config.filenames_font_size;
   #else
   form_id.FilenameListbox.p_font_name = Listman_global_persistent_data.config.filenames_fontname;
   form_id.FilenameListbox.p_font_size = Listman_global_persistent_data.config.filenames_font_size;
   #endif

   populate_filename_listbox(true, false, true, true, true, form_id);
}

definit()
{
   if (listman_datafile_name == '' || !file_exists(listman_datafile_name)) {
      listman_datafile_name = FIRST_LIST_DATA_FILENAME;
   }
   GFM_load_shortcut_list_data(listman_datafile_name);

   pic_index_col1_selected_active_file = gp_find_or_add_picture(GFM_BITMAP_PATH :+ '_Listman_selected_active_item.bmp');
   pic_index_col1_active_file = gp_find_or_add_picture(GFM_BITMAP_PATH :+ '_Listman_active_item.bmp');
   pic_index_col1_blank = gp_find_or_add_picture(GFM_BITMAP_PATH :+ '_GFM_fileview_col1_blank.bmp');
   pic_index_col1_selected_file = gp_find_or_add_picture(GFM_BITMAP_PATH :+ '_Listman_selected_item.bmp');
   


   if (the_lists._length() == 0) {
      check_and_create_default_lists();
      selected_list = 0;
      make_list_shortcuts_active(0);
   }
   int k = find_listname_index(_project_name);
   if (k >= 0) {
      make_list_shortcuts_active(k);
   }
   check_if_selected_list_is_valid();
}









/*************

http://community.slickedit.com/index.php?topic=242.0

*************/


/*  old code

static void populate_list_names_listbox(int form_id)
{
   _str stext;
   // disabling the listbox avoids the annoying dotted line that can appear
   // if the listbox receives the focus
   form_id.ListNamesListBox.p_enabled = false;
   form_id.ListNamesListBox._lbclear();

   listnames_listbox_index._makeempty();
   int inx = 0;

   if (selected_list == active_list) {
      if (selected_list >= 0 && selected_list < the_lists._length()) {
         stext = get_list_entry_text(selected_list);
         if (stext != '') {
            form_id.ListNamesListBox._lbadd_item(stext, 20, pic_index_col1_selected_active_file);
            listnames_listbox_index[inx++] = selected_list;
         }
      }
   }
   else {
      if (selected_list >= 0 && selected_list < the_lists._length()) {
         stext = get_list_entry_text(selected_list);
         if (stext != '') {
            form_id.ListNamesListBox._lbadd_item(stext, 20, pic_index_col1_selected_file);
            listnames_listbox_index[inx++] = selected_list;
         }
      }
      if (active_list >= 0 && active_list< the_lists._length()) {
         stext = get_list_entry_text(active_list);
         if (stext != '') {
            form_id.ListNamesListBox._lbadd_item(stext, 20, pic_index_col1_active_file);
            listnames_listbox_index[inx++] = active_list;
         }
      }
   }
   int k;
   for (k = 0; k < the_lists._length(); ++k) {
      if (k != selected_list && k != active_list) {
         stext = get_list_entry_text(k);
         if (stext != '') {
            listnames_listbox_index[inx++] = k;
            form_id.ListNamesListBox._lbadd_item(stext, 20, pic_index_col1_blank);
         }
      }
   }
   form_id.ListNamesListBox._lbtop();
   form_id.ListNamesListBox.p_enabled = true;
}


*/
